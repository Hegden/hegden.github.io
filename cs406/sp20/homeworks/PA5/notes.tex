\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{tabulary}
\usepackage{float}
\usepackage{lipsum}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{graphics}
\usepackage{listings}
\lstset
{ %Formatting for code in appendix
    language=C,
    basicstyle=\small,
    numbers=left,
    stepnumber=1,
    showstringspaces=false,
    tabsize=1,
    breaklines=true,
    breakatwhitespace=false,
}
\usepackage{xcolor}
\lstset{escapeinside={<@}{@>}}
\usepackage[T1]{fontenc}
\usepackage[parfill]{parskip}
\newcommand{\code}[1]{\textsf{#1}}
\setlength{\parindent}{0em}
\begin{document}
\begin{center}{\LARGE CS406: Compilers} \end{center}
\begin{center}{\large Programming Assignment 5: Functions,  Due: 10/4/2020} \end{center}

\bigskip



\section{Introduction}
Your goal in this step is to generate executable code for programs with multiple functions.
This means you will have to handle two aspects: (i) what should a {\em caller} function do to prepare for calling a subroutine; (ii) what should a {\em callee} function do to set up its local variables and environment?

\section{Function calls}
The primary mechanism for handling function calls is the {\em program stack}, which is where the local environment ({\em activation record} or {\em frame}) for each currently executing function (i.e., functions that have started executing but have not yet returned) is stored. 

\subsection{Activation records}
An activation record, or frame, stores all of the data required to execute a function. In particular, this means that the activation record stores all of the local variables in a function.

{\em We declare global variables with \texttt{var} declarations in Tiny code, but that doesn't work for local variables. Why? Because a local variable is specific to {\em that} function invocation -- it's not global. Consider what would happen if you wrote a recursive function: the two versions of that recursive function each need their own copy of their local variables. }

An activation record is delimited by two ``pointers'': the {\em stack} pointer (which is controlled with the instructions \texttt{push} and \texttt{pop}) and the {\em frame} pointer (which is controlled with the instructions \texttt{link} and \texttt{unlink}). The stack pointer points to the ``top'' of the stack, while the frame pointer points to the ``base'' of the activation record.

Local variables (as well as arguments to a function, and its return value) are assigned ``slots'' on the stack relative to the frame pointer. When you access a local variable \texttt{x}, you won't access a memory location named \texttt{x} (as if it were a global variable); instead, you'll access a memory location that is ``3 slots below the frame pointer''

{\em In our stack organization, the stack conceptually grows ``down''. Local variables thus have negative offsets from the frame pointer, while arguments and return values have positive offsets from the frame pointer}

You will need to augment your symbol table to maintain a mapping between each local variable and its slot in an activation record. (Don't forget to reset the slot counter for each new function!)

We recommend that you draw out the program stack for a simple program to understand how to correctly generate code for it.

\subsection{Implementing a function call}
You can divide up the work done for a function call into two responsibilities: those of the {\em caller} and those of the {\em callee}. Here is what each one needs to do:

\paragraph{Caller before the call}
\begin{enumerate}
	\item Push any registers that you want to save on the stack (using \texttt{push})
	\item Push a space on the stack for the return value of the callee
	\item Push any arguments onto the stack
	\item Call the function (using \texttt{jsr})
\end{enumerate}

{\em Note: in some of the outputs, step 1 is performed after 2 and 3; this is fine, as long as you are consistent and are able to correctly know where arguments/return values are}

\paragraph{Callee}
\begin{enumerate}
	\item Allocate space on the stack for all the local variables (using \texttt{link})
	\item Generate code, accessing local variables and arguments to the function relative to the frame pointer (Use \texttt{\$-n} to access slots below the frame pointer, with $n$ replaced with the slot location, and \texttt{\$n} to access slots above the frame pointer)
	\item When returning from the function, save the return value (if any) in the appropriate slot ``above'' the frame pointer (remember how the caller set up its portion of the stack).
	\item Deallocate the activation record (using \texttt{unlink})
	\item Return to the caller (using \texttt{ret})
\end{enumerate}

\paragraph{Caller after the call}
\begin{enumerate}
	\item Pop arguments off the stack
	\item Pop the return value of the stack, remembering to store it in an appropriate place (local variable, global variable, register, etc., as needed by the source code)
	\item Pop any saved registers off the stack.
\end{enumerate}

{\em In this step, your code generation strategy likely means that no registers actually need to be saved on the stack by the caller, because none are ``live'' across the function call. If you choose not to save registers in this step, remember to add that functionality back in for the next step (register allocation) }

\paragraph{Testing your Tiny code}
You can test your Tiny code by using the same simulator as in the previous step.

\section{What you need to do}
In this step, you will be generating assembly code for function calls, as described above. You should correctly be able to handle functions with return values, functions where complex expressions are passed in as arguments (store the result in a temporary, then push that temporary onto the stack as the argument), and recursive functions.

\paragraph{Handling errors}
All the inputs we will give you in this step will be valid programs. We will also ensure that all expressions are type safe: a given expression will operate on either INTs or FLOATs, but not a mix, and all assignment statements will assign INT results to variables that are declared as INTs (and respectively for FLOATs).

\paragraph{Sample inputs and outputs:} \href{https://hegden.github.io/cs406/homeworks/PA5/input.zip}{inputs} and \href{https://hegden.github.io/cs406/homeworks/PA5/output.zip}{outputs}.

\paragraph{Grading}
In this step, we will only grade your compiler on the correctness of the generated code. We will run your generated code through the Tiny simulator and check to make sure that you produce the same result as our code. When we say result, we mean the outputs of any WRITE statements in the program (not details such as how many cycles the code uses, how many registers, etc.)

We will not check to see if you generate exactly the same code that we do -- no need to diff anything. We only care if your generated code {\em works correctly}. You may generate slightly different code than we did.

\section{What you need to submit}
\begin{itemize}
	\item All of the necessary code for your compiler that you wrote yourself. You do not need to include the ANTLR jar files if you are using ANTLR.
	\item A Makefile with the following targets:
		\begin{enumerate}
			\item \texttt{compiler}: this target will build your compiler
			\item \texttt{clean}: this target will remove any intermediate files that were created to build the compiler
			\item \texttt{team}: this target will print the same team information that you printed in step 0.
		\end{enumerate}

	\item A shell script (this must be written in bash) called \texttt{runme} that runs your scanner. This script should take in two arguments: first, the input file to the scanner and second, the filename where you want to put the scanner's output. You can assume that we will have run \texttt{make compiler} before running this script.
\end{itemize}
	
	While you may create as many other directories as you would like to organize your code or any intermediate products of the compilation process, both your \texttt{Makefile} and your \texttt{runme} script should be in the root directory of your repository.

{\em Do not submit any binaries}. Your git repo should only contain source files; no products of compilation.

You should tag your step 5 submission as \texttt{submission}
\end{document}
